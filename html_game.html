<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Aim Trainer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #151515;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        body.in-game {
            cursor: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            perspective: 800px; /* Reduced FOV to around 90 degrees */
        }

        #camera {
            position: absolute;
            width: 100%;
            height: 100%;
            perspective-origin: 50% 50%;
            transform-style: preserve-3d;
            transform-origin: 50% 50%;
            /* Initial transform to set proper view */
            transform: perspective(1200px) rotateX(0deg) rotateY(0deg);
        }

        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            top: 0;
            left: 0;
            transform-origin: 50% 50%;
        }

        #wall {
            position: absolute;
            width: 4000px;
            height: 2400px;
            background: linear-gradient(to bottom, #555 0%, #777 100%);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) translateZ(-3000px);
            border: 2px solid #333;
        }

        .target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffff00 0%, #ffff00 70%, #ffd700 70%, #ffd700 100%);
            box-shadow: 0 0 10px 2px rgba(255, 255, 0, 0.5);
            z-index: 5;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: "";
            position: absolute;
            background-color: white;
        }

        #crosshair::before {
            width: 2px;
            height: 8px;
            left: 3px;
            top: 0;
        }

        #crosshair::after {
            width: 8px;
            height: 2px;
            left: 0;
            top: 3px;
        }

        .hit-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 0, 0.8);
            animation: hitExpand 0.3s forwards;
            pointer-events: none;
            z-index: 200;
        }

        @keyframes hitExpand {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            pointer-events: none;
        }

        #score, #timer, #accuracy {
            margin-bottom: 10px;
        }

        #task-type {
            margin-bottom: 10px;
            font-weight: bold;
            color: #ffcc00;
        }

        /* Home Screen Styles */
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #151515;
            color: white;
            z-index: 200;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .home-container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #ffcc00;
            text-transform: uppercase;
        }

        .header p {
            font-size: 18px;
            color: #ccc;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            margin-bottom: 40px;
        }

        .instructions {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            background-color: #222;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .instructions h2 {
            color: #ffcc00;
            margin-top: 0;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }

        .instructions li {
            margin-bottom: 12px;
        }

        .mode-selection {
            flex: 1;
            min-width: 300px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .task-cards-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            gap: 16px;
        }

        .task-card {
            width: 100%;
            height: auto;
            padding: 16px 24px;
            background-color: #333;
            border-radius: 8px;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: row;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .task-card:hover {
            transform: translateX(8px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background-color: #444;
        }

        .task-card h3 {
            margin: 0;
            color: #ffcc00;
            min-width: 150px;
        }

        .task-card-content {
            flex-grow: 1;
            margin-left: 16px;
        }

        .task-card p {
            margin: 8px 0;
        }

        .duration-badge {
            background-color: #2a2a2a;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 4px;
            display: inline-block;
        }

        /* Results Section */
        .results-section {
            width: 100%;
            padding: 20px;
            background-color: #222;
            border-radius: 10px;
            margin-bottom: 40px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none; /* Initially hidden until there are results */
        }

        .results-section h2 {
            color: #ffcc00;
            margin-top: 0;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }

        .results-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-top: 20px;
        }

        .result-item {
            text-align: center;
            margin: 10px;
            min-width: 150px;
        }

        .result-value {
            font-size: 32px;
            font-weight: bold;
            color: #ffcc00;
        }

        .result-label {
            color: #ccc;
        }

        footer {
            text-align: center;
            margin-top: auto;
            padding: 20px;
            color: #777;
            font-size: 14px;
        }

        /* Game Screens */
        #game-screen, #end-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 200;
        }

        #end-screen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }

        #end-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffcc00;
        }

        button {
            padding: 12px 24px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #45a049;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 14px;
            margin-left: 10px;
            vertical-align: middle;
        }

        /* Grid pattern for mode 3 */
        .grid-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Home Screen / Hub -->
        <div id="home-screen">
            <div class="decorative-circle decorative-circle-1"></div>
            <div class="decorative-circle decorative-circle-2"></div>
            <div class="home-container">
                <div class="header">
                    <h1>FPS Aim Trainer</h1>
                    <p>Sharpen your precision with targeted training exercises</p>
                </div>
                
                <div class="results-section" id="results-section">
                    <h2>Your Recent Results</h2>
                    <div class="results-content">
                        <div class="result-item">
                            <div class="result-value" id="result-score">0</div>
                            <div class="result-label">Score</div>
                        </div>
                        <div class="result-item">
                            <div class="result-value" id="result-accuracy">0%</div>
                            <div class="result-label">Accuracy</div>
                        </div>
                        <div class="result-item">
                            <div class="result-value" id="result-targets">0</div>
                            <div class="result-label">Targets Hit</div>
                        </div>
                        <div class="result-item">
                            <div class="result-value" id="result-mode">-</div>
                            <div class="result-label">Last Mode</div>
                        </div>
                    </div>
                </div>
                
                <div class="main-content">
                    <div class="instructions">
                        <h2>How to Play</h2>
                        <ol>
                            <li><strong>Select a training mode</strong> from the options on the right.</li>
                            <li><strong>Use your mouse</strong> to aim at targets. Each session lasts 60 seconds.</li>
                            <li><strong>Click to shoot</strong> at the yellow targets on the wall.</li>
                            <li><strong>Focus on accuracy</strong> - targets remain until shot.</li>
                            <li><strong>Try different modes</strong> to train specific skills:
                                <ul>
                                    <li><strong>Standard:</strong> General aim practice with random targets</li>
                                    <li><strong>Micro Adjustment:</strong> Precision practice with aligned targets</li>
                                    <li><strong>Grid Tracking:</strong> Quick target acquisition in a structured pattern</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Tip:</strong> For best results, use a consistent mouse sensitivity and practice regularly.</p>
                    </div>
                    
                    <div class="mode-selection">
                        <h2>Select Training Mode</h2>
                        <div class="task-cards-container">
                            <div class="task-card" data-task-type="standard" id="standard-task">
                                <h3>Standard</h3>
                                <div class="task-card-content">
                                    <p>Targets appear randomly across the wall at varying sizes. Builds general aim skills.</p>
                                    <span class="duration-badge">60 seconds</span>
                                </div>
                            </div>
                            
                            <div class="task-card" data-task-type="micro" id="micro-task">
                                <h3>Micro Adjustment</h3>
                                <div class="task-card-content">
                                    <p>Small targets appear in an aligned formation. Improves precision and small movements.</p>
                                    <span class="duration-badge">60 seconds</span>
                                </div>
                            </div>
                            
                            <div class="task-card" data-task-type="grid" id="grid-task">
                                <h3>Grid Tracking</h3>
                                <div class="task-card-content">
                                    <p>Targets appear in a 3Ã—3 grid pattern. Improves target acquisition and speed.</p>
                                    <span class="duration-badge">60 seconds</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <footer>
                    <span style="opacity: 0.8;">FPS Aim Trainer</span> | <span style="color: #ffcc00;">Train your aim</span>, level up your game
                </footer>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div id="camera">
                <div id="world">
                    <div id="wall"></div>
                </div>
            </div>
            
            <div id="crosshair"></div>
            
            <div id="ui">
                <div id="task-type">Task: Standard</div>
                <div id="score">Score: 0</div>
                <div id="timer">Time: 60</div>
                <div id="accuracy">Accuracy: 0%</div>
            </div>
        </div>
        
        <!-- End Screen -->
        <div id="end-screen">
            <h1>Task Complete</h1>
            <h2 id="final-score">Score: 0</h2>
            <h2 id="final-accuracy">Accuracy: 0%</h2>
            <h2 id="final-targets">Targets Hit: 0</h2>
            <button id="return-home-btn">Return to Home</button>
        </div>
    </div>

    <script>
        // Game variables
        let score = 0;
        let hits = 0;
        let shots = 0;
        let timeLeft = 60;
        let gameActive = false;
        let gameTimer;
        let targets = [];
        let targetSpawnTimer;
        let rotationX = 0;
        let rotationY = 0;
        let sensitivity = 0.15;
        let isPointerLocked = false;
        let currentTaskType = 'standard';
        let gridPoints = [];
        let usedPositions = [];
        let resultsHistory = [];

        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const camera = document.getElementById('camera');
        const wall = document.getElementById('wall');
        const world = document.getElementById('world');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const accuracyElement = document.getElementById('accuracy');
        const taskTypeElement = document.getElementById('task-type');
        const homeScreen = document.getElementById('home-screen');
        const gameScreen = document.getElementById('game-screen');
        const endScreen = document.getElementById('end-screen');
        const returnHomeBtn = document.getElementById('return-home-btn');
        const finalScoreElement = document.getElementById('final-score');
        const finalAccuracyElement = document.getElementById('final-accuracy');
        const finalTargetsElement = document.getElementById('final-targets');
        const crosshair = document.getElementById('crosshair');
        const taskCards = document.querySelectorAll('.task-card');
        const resultsSection = document.getElementById('results-section');
        const resultScoreElement = document.getElementById('result-score');
        const resultAccuracyElement = document.getElementById('result-accuracy');
        const resultTargetsElement = document.getElementById('result-targets');
        const resultModeElement = document.getElementById('result-mode');

        // Initialize game
        function init() {
            returnHomeBtn.addEventListener('click', returnToHome);
            document.addEventListener('click', handleShot);
            document.addEventListener('pointerlockchange', pointerLockChange);
            document.addEventListener('mousemove', handleMouseMove);
            
            // Setup task selection - using event delegation
            const taskCardsContainer = document.querySelector('.task-cards-container');
            taskCardsContainer.addEventListener('click', (event) => {
                // Find the closest task-card parent
                const taskCard = event.target.closest('.task-card');
                if (taskCard && taskCard.dataset.taskType) {
                    currentTaskType = taskCard.dataset.taskType;
                    startTask(currentTaskType);
                }
            });
            
            // Create grid points for the grid task
            createGridPoints();
            
            // Add center marker (invisible)
            addCenterMarker();
        }

        // Show home screen
        function returnToHome() {
            endScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
            
            // Reset game state
            resetGameState();
            
            // Display results if available
            if (resultsHistory.length > 0) {
                updateResultsDisplay();
                resultsSection.style.display = 'block';
            }
        }
        
        // Update the results display in the home screen
        function updateResultsDisplay() {
            // Get the most recent result
            const latestResult = resultsHistory[0];
            
            // Update the UI
            resultScoreElement.textContent = latestResult.score;
            resultAccuracyElement.textContent = latestResult.accuracy + '%';
            resultTargetsElement.textContent = latestResult.hits;
            resultModeElement.textContent = formatTaskName(latestResult.taskType);
        }
        
        // Reset game state
        function resetGameState() {
            // Clear timers
            clearInterval(gameTimer);
            clearInterval(targetSpawnTimer);
            
            // Reset variables
            score = 0;
            hits = 0;
            shots = 0;
            timeLeft = 60;
            rotationX = 0;
            rotationY = 0;
            gameActive = false;
            
            // Show cursor
            document.body.classList.remove('in-game');
            
            // Exit pointer lock if active
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
            
            // Remove all targets
            targets.forEach(target => {
                if (target.element && target.element.parentNode) {
                    target.element.parentNode.removeChild(target.element);
                }
            });
            targets = [];
            
            // Update UI
            scoreElement.textContent = `Score: ${score}`;
            timerElement.textContent = `Time: ${timeLeft}`;
            accuracyElement.textContent = `Accuracy: ${calculateAccuracy()}%`;
            updateViewRotation();
        }

        // Start a specific task
        function startTask(taskType) {
            console.log("Starting task:", taskType);
            homeScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            currentTaskType = taskType;
            gameActive = true;
            
            // Hide cursor during gameplay
            document.body.classList.add('in-game');
            
            requestPointerLock();
            
            // Update task type display
            taskTypeElement.textContent = `Task: ${formatTaskName(taskType)}`;
            
            // Initial target spawn based on task type
            spawnInitialTargets();
            
            // Start timer (60 seconds for all tasks)
            gameTimer = setInterval(() => {
                timeLeft--;
                timerElement.textContent = `Time: ${timeLeft}`;
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            // Start target spawning based on task type
            startTargetSpawning();
        }
        
        // Format task name for display
        function formatTaskName(taskType) {
            switch(taskType) {
                case 'standard': return 'Standard';
                case 'micro': return 'Micro Adjustment';
                case 'grid': return 'Grid Tracking';
                default: return 'Unknown';
            }
        }
        
        // Spawn initial targets based on task type
        function spawnInitialTargets() {
            // Clear any existing targets first
            targets.forEach(target => {
                if (target.element && target.element.parentNode) {
                    target.element.parentNode.removeChild(target.element);
                }
            });
            targets = [];
            
            // Reset position tracking
            usedPositions = [];
            window.microAdjustMode = null;
            
            switch(currentTaskType) {
                case 'standard':
                    // Spawn 5 random targets
                    for (let i = 0; i < 5; i++) {
                        spawnTarget();
                    }
                    break;
                case 'micro':
                    // Spawn 3 small targets in aligned formation
                    for (let i = 0; i < 3; i++) {
                        spawnMicroTarget();
                    }
                    break;
                case 'grid':
                    // Spawn 5 targets on grid points
                    for (let i = 0; i < 5; i++) {
                        spawnGridTarget();
                    }
                    break;
            }
        }
        
        // Start target spawning based on task type
        function startTargetSpawning() {
            // We don't need interval-based spawning anymore since targets remain
            // until hit. We'll just make sure we have the right number of initial targets.
            if (targetSpawnTimer) {
                clearInterval(targetSpawnTimer);
                targetSpawnTimer = null;
            }
            
            // Reset tracking state for micro adjustments
            window.microAdjustMode = null;
            usedPositions = [];
        }

        // Create grid points for the grid task
        function createGridPoints() {
            gridPoints = [];
            
            // Define a 3x3 grid
            const rows = 3;
            const cols = 3;
            const spacing = 300; // Space between grid points
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate position (centered on screen)
                    const x = (col - 1) * spacing;
                    const y = (row - 1) * spacing;
                    
                    gridPoints.push({ x, y });
                }
            }
        }

        // End game
        function endGame() {
            gameActive = false;
            document.exitPointerLock();
            clearInterval(gameTimer);
            clearInterval(targetSpawnTimer);
            
            // Show cursor again
            document.body.classList.remove('in-game');
            
            // Remove all targets
            targets.forEach(target => {
                if (target.element && target.element.parentNode) {
                    target.element.parentNode.removeChild(target.element);
                }
            });
            targets = [];
            
            // Calculate final results
            const accuracy = calculateAccuracy();
            
            // Store results
            const results = {
                score: score,
                accuracy: accuracy,
                hits: hits,
                shots: shots,
                taskType: currentTaskType,
                date: new Date()
            };
            
            // Add to history (most recent first)
            resultsHistory.unshift(results);
            
            // Show end screen
            finalScoreElement.textContent = `Score: ${score}`;
            finalAccuracyElement.textContent = `Accuracy: ${accuracy}%`;
            finalTargetsElement.textContent = `Targets Hit: ${hits}`;
            gameScreen.style.display = 'none';
            endScreen.style.display = 'flex';
        }

        // Calculate accuracy percentage
        function calculateAccuracy() {
            if (shots === 0) return 0;
            return Math.round((hits / shots) * 100);
        }

        // Request pointer lock
        function requestPointerLock() {
            gameContainer.requestPointerLock = gameContainer.requestPointerLock || 
                                           gameContainer.mozRequestPointerLock ||
                                           gameContainer.webkitRequestPointerLock;
            gameContainer.requestPointerLock();
        }

        // Handle pointer lock change
        function pointerLockChange() {
            isPointerLocked = document.pointerLockElement === gameContainer ||
                            document.mozPointerLockElement === gameContainer ||
                            document.webkitPointerLockElement === gameContainer;
                            
            if (!isPointerLocked && gameActive) {
                // Game was active but pointer lock was lost
                // For simplicity, we'll just continue
            }
        }

        // Handle mouse movement for FPS camera
        function handleMouseMove(e) {
            if (!isPointerLocked || !gameActive) return;
            
            // Get mouse movement
            const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
            const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
            
            // Update camera rotation (fixed inversion for left/right)
            rotationY += movementX * sensitivity;
            rotationX -= movementY * sensitivity;
            
            // Limit vertical rotation (looking up/down)
            rotationX = Math.max(-90, Math.min(90, rotationX));
            
            // Apply rotation to the camera view
            updateViewRotation();
        }

        // Update the camera view rotation
        function updateViewRotation() {
            camera.style.transform = `perspective(1200px) rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
        }

        // Standard target spawn (random placement)
        function spawnTarget() {
            if (!gameActive) return;
            
            // Create target element
            const targetElement = document.createElement('div');
            targetElement.className = 'target';
            
            // Wall dimensions
            const wallWidth = 4000;
            const wallHeight = 2400;
            const size = Math.random() * 30 + 40; // Size between 40-70px
            
            // Position relative to wall center
            const padding = size * 2;
            const maxX = wallWidth - padding*2;
            const maxY = wallHeight - padding*2;
            
            let x = (Math.random() * maxX - maxX/2);
            let y = (Math.random() * maxY - maxY/2);
            
            // Check if position is too close to existing targets
            const minDistance = 100; // Minimum distance between targets
            let positionValid = false;
            let attempts = 0;
            
            while (!positionValid && attempts < 10) {
                positionValid = true;
                
                // Check distance to all existing targets
                for (const target of targets) {
                    const distance = Math.sqrt(
                        Math.pow(target.x - x, 2) + 
                        Math.pow(target.y - y, 2)
                    );
                    
                    if (distance < minDistance) {
                        positionValid = false;
                        break;
                    }
                }
                
                // If position is invalid, try a new one
                if (!positionValid) {
                    x = (Math.random() * maxX - maxX/2);
                    y = (Math.random() * maxY - maxY/2);
                    attempts++;
                }
            }
            
            // Set position and size
            targetElement.style.width = `${size}px`;
            targetElement.style.height = `${size}px`;
            targetElement.style.position = 'absolute';
            targetElement.style.left = '50%';
            targetElement.style.top = '50%';
            targetElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            
            // Add to wall
            wall.appendChild(targetElement);
            
            // Store target data
            addTargetToList(targetElement, x, y, 0, size);
            
            // No automatic lifespan - targets remain until hit
        }
        
        // Micro target spawn (aligned targets)
        function spawnMicroTarget() {
            if (!gameActive) return;
            
            // Create smaller target element
            const targetElement = document.createElement('div');
            targetElement.className = 'target';
            
            // Small size for micro adjustment practice
            const size = Math.random() * 15 + 20; // Size between 20-35px
            
            // Determine if we're doing horizontal or vertical alignment
            // We'll keep this consistent within a session
            if (!window.microAdjustMode) {
                // Randomly choose horizontal or vertical alignment for this session
                window.microAdjustMode = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                window.microAdjustFixedCoord = 0; // Fixed at center line
            }
            
            let x, y;
            if (window.microAdjustMode === 'horizontal') {
                // Fixed Y coordinate (horizontal line)
                y = window.microAdjustFixedCoord;
                // Random X position within reasonable range
                x = (Math.random() * 300 - 150);
            } else {
                // Fixed X coordinate (vertical line)
                x = window.microAdjustFixedCoord;
                // Random Y position within reasonable range
                y = (Math.random() * 300 - 150);
            }
            
            // Check if position is too close to existing targets
            const minDistance = 80; // Minimum distance between target centers
            
            // Retry up to 10 times if position is too close to existing targets
            let attempts = 0;
            let positionValid = false;
            
            while (!positionValid && attempts < 10) {
                positionValid = true;
                
                // Check distance to all existing targets
                for (const target of targets) {
                    const distance = window.microAdjustMode === 'horizontal' 
                        ? Math.abs(target.x - x) // Only check x distance for horizontal mode
                        : Math.abs(target.y - y); // Only check y distance for vertical mode
                    
                    if (distance < minDistance) {
                        positionValid = false;
                        break;
                    }
                }
                
                // Check if too close to recently used positions
                for (const pos of usedPositions) {
                    const distance = window.microAdjustMode === 'horizontal'
                        ? Math.abs(pos.x - x)
                        : Math.abs(pos.y - y);
                        
                    if (distance < minDistance) {
                        positionValid = false;
                        break;
                    }
                }
                
                // If position is invalid, try a new one
                if (!positionValid) {
                    if (window.microAdjustMode === 'horizontal') {
                        x = (Math.random() * 300 - 150);
                    } else {
                        y = (Math.random() * 300 - 150);
                    }
                    attempts++;
                }
            }
            
            // Remember this position to avoid spawning here again
            usedPositions.push({x, y});
            if (usedPositions.length > 10) {
                usedPositions.shift(); // Keep only the 10 most recent positions
            }
            
            // Set position and size
            targetElement.style.width = `${size}px`;
            targetElement.style.height = `${size}px`;
            targetElement.style.position = 'absolute';
            targetElement.style.left = '50%';
            targetElement.style.top = '50%';
            targetElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            
            // Add to wall
            wall.appendChild(targetElement);
            
            // Store target data
            addTargetToList(targetElement, x, y, 0, size);
            
            // No automatic lifespan - targets remain until hit
        }
        
        // Grid target spawn (3x3 grid)
        function spawnGridTarget() {
            if (!gameActive || gridPoints.length === 0) return;
            
            // Create larger target element
            const targetElement = document.createElement('div');
            targetElement.className = 'target';
            
            // Slightly larger size for quick acquisition
            const size = Math.random() * 15 + 60; // Size between 60-75px
            
            // Track which grid points are already occupied
            const occupiedGridPoints = targets.map(t => {
                return gridPoints.findIndex(gp => 
                    Math.abs(gp.x - t.x) < 10 && Math.abs(gp.y - t.y) < 10
                );
            }).filter(index => index !== -1);
            
            // Filter available grid points
            const availablePoints = gridPoints.filter((_, index) => 
                !occupiedGridPoints.includes(index)
            );
            
            // If all grid points are occupied, choose a random one
            // Otherwise pick from the available points
            let gridPoint;
            if (availablePoints.length === 0) {
                gridPoint = gridPoints[Math.floor(Math.random() * gridPoints.length)];
            } else {
                gridPoint = availablePoints[Math.floor(Math.random() * availablePoints.length)];
            }
            
            const x = gridPoint.x;
            const y = gridPoint.y;
            
            // Set position and size
            targetElement.style.width = `${size}px`;
            targetElement.style.height = `${size}px`;
            targetElement.style.position = 'absolute';
            targetElement.style.left = '50%';
            targetElement.style.top = '50%';
            targetElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            
            // Add to wall
            wall.appendChild(targetElement);
            
            // Store target data
            addTargetToList(targetElement, x, y, 0, size);
            
            // No automatic lifespan - targets remain until hit
        }
        
        // Add target to tracking list
        function addTargetToList(targetElement, x, y, z, size) {
            const targetId = Date.now() + Math.random();
            targetElement.dataset.id = targetId;
            
            const target = {
                id: targetId,
                element: targetElement,
                x, y, z, size,
                worldX: x,
                worldY: y,
                worldZ: z
            };
            
            targets.push(target);
            return targetId;
        }
        
        // Note: We're no longer using automatic lifespans
        // This function is kept for backward compatibility but won't be used
        function setupTargetLifespan(targetElement, lifespan) {
            // Function intentionally empty - targets now remain until hit
        }

        // Handle shot (click)
        function handleShot(event) {
            if (!gameActive || !isPointerLocked) {
                if (!isPointerLocked && gameActive) {
                    requestPointerLock();
                }
                return;
            }
            
            shots++;
            
            // Ray from center of screen
            const ray = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2
            };
            
            // Check if any target is hit
            const targetElements = document.querySelectorAll('.target');
            let hit = false;
            
            targetElements.forEach(targetElement => {
                // Get target's position on screen
                const rect = targetElement.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Distance from crosshair to target center
                const distance = Math.sqrt(
                    Math.pow(ray.x - centerX, 2) + 
                    Math.pow(ray.y - centerY, 2)
                );
                
                // Hit detection radius varies by task
                let hitRadius = rect.width * 0.4; // Standard hit radius
                
                if (currentTaskType === 'micro') {
                    hitRadius = rect.width * 0.3; // Smaller hit area for micro mode
                } else if (currentTaskType === 'grid') {
                    hitRadius = rect.width * 0.5; // Larger hit area for grid mode
                }
                
                if (distance < hitRadius) {
                    // Hit a target!
                    hit = true;
                    hits++;
                    
                    // Score varies by task type and target size
                    let pointValue = 100; // Base score for standard
                    
                    if (currentTaskType === 'micro') {
                        // More points for smaller targets
                        pointValue = 150;
                    } else if (currentTaskType === 'grid') {
                        // Fewer points for larger grid targets
                        pointValue = 75;
                    }
                    
                    score += pointValue;
                    
                    // Remove the target
                    const targetId = targetElement.dataset.id;
                    targets = targets.filter(t => t.id !== targetId);
                    targetElement.parentNode.removeChild(targetElement);
                    
                    // Create hit effect at center of screen
                    createHitEffect(ray.x, ray.y);
                    
                    // Update score
                    scoreElement.textContent = `Score: ${score}`;
                    
                    // Spawn a replacement based on task type
                    setTimeout(() => {
                        if (gameActive) {
                            switch(currentTaskType) {
                                case 'standard': spawnTarget(); break;
                                case 'micro': spawnMicroTarget(); break;
                                case 'grid': spawnGridTarget(); break;
                            }
                        }
                    }, 300);
                }
            });
            
            // Update accuracy
            accuracyElement.textContent = `Accuracy: ${calculateAccuracy()}%`;
        }

        // Create hit effect
        function createHitEffect(x, y) {
            const hitEffect = document.createElement('div');
            hitEffect.className = 'hit-effect';
            hitEffect.style.left = `${x - 20}px`;
            hitEffect.style.top = `${y - 20}px`;
            
            gameContainer.appendChild(hitEffect);
            
            // Remove after animation
            setTimeout(() => {
                if (hitEffect.parentNode) {
                    hitEffect.parentNode.removeChild(hitEffect);
                }
            }, 300);
        }

        // Add a center marker indicator to ensure proper alignment (invisible)
        function addCenterMarker() {
            const centerMarker = document.createElement('div');
            centerMarker.style.position = 'absolute';
            centerMarker.style.width = '10px';
            centerMarker.style.height = '10px';
            centerMarker.style.borderRadius = '50%';
            centerMarker.style.backgroundColor = 'rgba(0, 255, 0, 0)'; // Completely transparent
            centerMarker.style.left = '50%';
            centerMarker.style.top = '50%';
            centerMarker.style.transform = 'translate(-50%, -50%) translateZ(-3000px)';
            centerMarker.style.zIndex = '1';
            wall.appendChild(centerMarker);
        }

        // Initialize the game
        init();
    </script>
</body>
</html>